From 12f330b8556e45d5454227be6e1168e16e9fa7ce Mon Sep 17 00:00:00 2001
From: Andrew Gunnerson <andrewgunnerson@gmail.com>
Date: Fri, 1 Aug 2014 16:33:40 -0400
Subject: [PATCH] Add loki JNI shared library

---
 Android.mk     | 20 ++++------------
 Application.mk |  2 ++
 loki.h         | 11 +++++++++
 loki_find.c    | 14 +++++------
 loki_flash.c   | 28 +++++++++++-----------
 loki_jni.c     | 74 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 loki_patch.c   | 52 ++++++++++++++++++++---------------------
 loki_unlok.c   | 28 +++++++++++-----------
 8 files changed, 153 insertions(+), 76 deletions(-)
 create mode 100644 Application.mk
 create mode 100644 loki_jni.c

diff --git a/Android.mk b/Android.mk
index 8a81933..c03b1d4 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,19 +1,9 @@
 LOCAL_PATH := $(call my-dir)
 
-# libloki
+# libloki JNI
 include $(CLEAR_VARS)
-LOCAL_SRC_FILES := loki_flash.c loki_patch.c
-LOCAL_MODULE := libloki_static
+LOCAL_SRC_FILES := loki_flash.c loki_patch.c loki_find.c loki_unlok.c loki_jni.c
+LOCAL_MODULE := libloki-jni
 LOCAL_MODULE_TAGS := eng
-include $(BUILD_STATIC_LIBRARY)
-
-# build static binary
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES := loki_flash.c loki_patch.c loki_find.c loki_unlok.c main.c
-LOCAL_MODULE := loki_tool_static
-LOCAL_MODULE_STEM := loki_tool
-LOCAL_MODULE_TAGS := eng
-# LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/sbin
-LOCAL_STATIC_LIBRARIES := libc
-LOCAL_FORCE_STATIC_EXECUTABLE := true
-include $(BUILD_EXECUTABLE)
+LOCAL_LDLIBS := -llog
+include $(BUILD_SHARED_LIBRARY)
diff --git a/Application.mk b/Application.mk
new file mode 100644
index 0000000..4d7397b
--- /dev/null
+++ b/Application.mk
@@ -0,0 +1,2 @@
+APP_ABI := all
+APP_PLATFORM := android-17
diff --git a/loki.h b/loki.h
index c1d6b3e..3ba1b5c 100644
--- a/loki.h
+++ b/loki.h
@@ -1,6 +1,17 @@
 #ifndef __LOKI_H_
 #define __LOKI_H_
 
+#include <android/log.h>
+
+#define LOG_TAG "loki"
+
+#define LOG(prio, tag, fmt...) __android_log_print(prio, tag, fmt)
+#define LOGD(...) LOG(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
+#define LOGE(...) LOG(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
+#define LOGI(...) LOG(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
+#define LOGV(...) LOG(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
+#define LOGW(...) LOG(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
+
 #define VERSION "2.1"
 
 #define BOOT_MAGIC_SIZE 8
diff --git a/loki_find.c b/loki_find.c
index 151a309..8b4e9b5 100644
--- a/loki_find.c
+++ b/loki_find.c
@@ -20,18 +20,18 @@ int loki_find(const char* aboot_image)
 
 	aboot_fd = open(aboot_image, O_RDONLY);
 	if (aboot_fd < 0) {
-		printf("[-] Failed to open %s for reading.\n", aboot_image);
+		LOGE("[-] Failed to open %s for reading.", aboot_image);
 		return 1;
 	}
 
 	if (fstat(aboot_fd, &st)) {
-		printf("[-] fstat() failed.\n");
+		LOGE("[-] fstat() failed.");
 		return 1;
 	}
 
 	aboot = mmap(0, (st.st_size + 0xfff) & ~0xfff, PROT_READ, MAP_PRIVATE, aboot_fd, 0);
 	if (aboot == MAP_FAILED) {
-		printf("[-] Failed to mmap aboot.\n");
+		LOGE("[-] Failed to mmap aboot.");
 		return 1;
 	}
 
@@ -60,11 +60,11 @@ int loki_find(const char* aboot_image)
 	}
 
 	if (!check_sigs) {
-		printf("[-] Could not find signature checking function.\n");
+		LOGE("[-] Could not find signature checking function.");
 		return 1;
 	}
 
-	printf("[+] Signature check function: %.08lx\n", check_sigs);
+	LOGV("[+] Signature check function: %.08lx", check_sigs);
 
 	boot_mmc = 0;
 
@@ -81,11 +81,11 @@ int loki_find(const char* aboot_image)
     }
 
 	if (!boot_mmc) {
-		printf("[-] Could not find boot_linux_from_mmc.\n");
+		LOGE("[-] Could not find boot_linux_from_mmc.");
 		return 1;
 	}
 
-	printf("[+] boot_linux_from_mmc: %.08lx\n", boot_mmc);
+	LOGV("[+] boot_linux_from_mmc: %.08lx", boot_mmc);
 
 	return 0;
 }
diff --git a/loki_flash.c b/loki_flash.c
index 16bdd4d..b6ffe6f 100644
--- a/loki_flash.c
+++ b/loki_flash.c
@@ -30,32 +30,32 @@ int loki_flash(const char* partition_label, const char* loki_image)
 	} else if (!strcmp(partition_label, "recovery")) {
 		recovery = 1;
 	} else {
-		printf("[+] First argument must be \"boot\" or \"recovery\".\n");
+		LOGE("[+] First argument must be \"boot\" or \"recovery\".");
 		return 1;
 	}
 
 	/* Verify input file */
 	aboot_fd = open(ABOOT_PARTITION, O_RDONLY);
 	if (aboot_fd < 0) {
-		printf("[-] Failed to open aboot for reading.\n");
+		LOGE("[-] Failed to open aboot for reading.");
 		return 1;
 	}
 
 	ifd = open(loki_image, O_RDONLY);
 	if (ifd < 0) {
-		printf("[-] Failed to open %s for reading.\n", loki_image);
+		LOGE("[-] Failed to open %s for reading.", loki_image);
 		return 1;
 	}
 
 	/* Map the image to be flashed */
 	if (fstat(ifd, &st)) {
-		printf("[-] fstat() failed.\n");
+		LOGE("[-] fstat() failed.");
 		return 1;
 	}
 
 	orig = mmap(0, (st.st_size + 0x2000 + 0xfff) & ~0xfff, PROT_READ, MAP_PRIVATE, ifd, 0);
 	if (orig == MAP_FAILED) {
-		printf("[-] Failed to mmap Loki image.\n");
+		LOGE("[-] Failed to mmap Loki image.");
 		return 1;
 	}
 
@@ -64,20 +64,20 @@ int loki_flash(const char* partition_label, const char* loki_image)
 
 	/* Verify this is a Loki image */
 	if (memcmp(loki_hdr->magic, "LOKI", 4)) {
-		printf("[-] Input file is not a Loki image.\n");
+		LOGE("[-] Input file is not a Loki image.");
 		return 1;
 	}
 
 	/* Verify this is the right type of image */
 	if (loki_hdr->recovery != recovery) {
-		printf("[-] Loki image is not a %s image.\n", recovery ? "recovery" : "boot");
+		LOGE("[-] Loki image is not a %s image.", recovery ? "recovery" : "boot");
 		return 1;
 	}
 
 	/* Verify the to-be-patched address matches the known code pattern */
 	aboot = mmap(0, 0x40000, PROT_READ, MAP_PRIVATE, aboot_fd, 0);
 	if (aboot == MAP_FAILED) {
-		printf("[-] Failed to mmap aboot.\n");
+		LOGE("[-] Failed to mmap aboot.");
 		return 1;
 	}
 
@@ -97,7 +97,7 @@ int loki_flash(const char* partition_label, const char* loki_image)
 			patch = hdr->ramdisk_addr - ABOOT_BASE_G2 + aboot + offs;
 
 		if (patch < aboot || patch > aboot + 0x40000 - 8) {
-			printf("[-] Invalid .lok file.\n");
+			LOGE("[-] Invalid .lok file.");
 			return 1;
 		}
 
@@ -114,11 +114,11 @@ int loki_flash(const char* partition_label, const char* loki_image)
 	}
 
 	if (!match) {
-		printf("[-] Loki aboot version does not match device.\n");
+		LOGE("[-] Loki aboot version does not match device.");
 		return 1;
 	}
 
-	printf("[+] Loki validation passed, flashing image.\n");
+	LOGV("[+] Loki validation passed, flashing image.");
 
 	snprintf(outfile, sizeof(outfile),
 			 "%s",
@@ -126,16 +126,16 @@ int loki_flash(const char* partition_label, const char* loki_image)
 
 	ofd = open(outfile, O_WRONLY);
 	if (ofd < 0) {
-		printf("[-] Failed to open output block device.\n");
+		LOGE("[-] Failed to open output block device.");
 		return 1;
 	}
 
 	if (write(ofd, orig, st.st_size) != st.st_size) {
-		printf("[-] Failed to write to block device.\n");
+		LOGE("[-] Failed to write to block device.");
 		return 1;
 	}
 
-	printf("[+] Loki flashing complete!\n");
+	LOGV("[+] Loki flashing complete!");
 
 	close(ifd);
 	close(aboot_fd);
diff --git a/loki_jni.c b/loki_jni.c
new file mode 100644
index 0000000..b886645
--- /dev/null
+++ b/loki_jni.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2014  Andrew Gunnerson <andrewgunnerson@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <jni.h>
+#include "loki.h"
+
+JNIEXPORT jint JNICALL Java_com_github_chenxiaolong_dualbootpatcher_settings_AppSharingUtils_lokiPatch(
+        JNIEnv *env, jclass clazz, jstring jPartitionLabel, jstring jAbootImage,
+        jstring jInImage, jstring jOutImage) {
+    const char *partitionLabel = (*env)->GetStringUTFChars(env, jPartitionLabel, 0);
+    const char *abootImage = (*env)->GetStringUTFChars(env, jAbootImage, 0);
+    const char *inImage = (*env)->GetStringUTFChars(env, jInImage, 0);
+    const char *outImage = (*env)->GetStringUTFChars(env, jOutImage, 0);
+
+    jint ret = loki_patch(partitionLabel, abootImage, inImage, outImage);
+
+    (*env)->ReleaseStringUTFChars(env, jPartitionLabel, partitionLabel);
+    (*env)->ReleaseStringUTFChars(env, jAbootImage, abootImage);
+    (*env)->ReleaseStringUTFChars(env, jInImage, inImage);
+    (*env)->ReleaseStringUTFChars(env, jOutImage, outImage);
+
+    return ret;
+}
+
+JNIEXPORT jint JNICALL Java_com_github_chenxiaolong_dualbootpatcher_settings_AppSharingUtils_lokiFlash(
+        JNIEnv *env, jclass clazz, jstring jPartitionLabel, jstring jLokiImage) {
+    const char *partitionLabel = (*env)->GetStringUTFChars(env, jPartitionLabel, 0);
+    const char *lokiImage = (*env)->GetStringUTFChars(env, jLokiImage, 0);
+
+    jint ret = loki_flash(partitionLabel, lokiImage);
+
+    (*env)->ReleaseStringUTFChars(env, jPartitionLabel, partitionLabel);
+    (*env)->ReleaseStringUTFChars(env, jLokiImage, lokiImage);
+
+    return ret;
+}
+
+JNIEXPORT jint JNICALL Java_com_github_chenxiaolong_dualbootpatcher_settings_AppSharingUtils_lokiFind(
+        JNIEnv *env, jclass clazz, jstring jAbootImage) {
+    const char *abootImage = (*env)->GetStringUTFChars(env, jAbootImage, 0);
+
+    jint ret = loki_find(abootImage);
+
+    (*env)->ReleaseStringUTFChars(env, jAbootImage, abootImage);
+
+    return ret;
+}
+
+JNIEXPORT jint JNICALL Java_com_github_chenxiaolong_dualbootpatcher_settings_AppSharingUtils_lokiUnlok(
+        JNIEnv *env, jclass clazz, jstring jInImage, jstring jOutImage) {
+    const char *inImage = (*env)->GetStringUTFChars(env, jInImage, 0);
+    const char *outImage = (*env)->GetStringUTFChars(env, jOutImage, 0);
+
+    jint ret = loki_unlok(inImage, outImage);
+
+    (*env)->ReleaseStringUTFChars(env, jInImage, inImage);
+    (*env)->ReleaseStringUTFChars(env, jOutImage, outImage);
+
+    return ret;
+}
diff --git a/loki_patch.c b/loki_patch.c
index 923a0f3..f1a8b2e 100644
--- a/loki_patch.c
+++ b/loki_patch.c
@@ -454,38 +454,38 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	} else if (!strcmp(partition_label, "recovery")) {
 		recovery = 1;
 	} else {
-		printf("[+] First argument must be \"boot\" or \"recovery\".\n");
+		LOGE("[+] First argument must be \"boot\" or \"recovery\".");
 		return 1;
 	}
 
 	/* Open input files */
 	aboot_fd = open(aboot_image, O_RDONLY);
 	if (aboot_fd < 0) {
-		printf("[-] Failed to open %s for reading.\n", aboot_image);
+		LOGE("[-] Failed to open %s for reading.", aboot_image);
 		return 1;
 	}
 
 	ifd = open(in_image, O_RDONLY);
 	if (ifd < 0) {
-		printf("[-] Failed to open %s for reading.\n", in_image);
+		LOGE("[-] Failed to open %s for reading.", in_image);
 		return 1;
 	}
 
 	ofd = open(out_image, O_WRONLY|O_CREAT|O_TRUNC, 0644);
 	if (ofd < 0) {
-		printf("[-] Failed to open %s for writing.\n", out_image);
+		LOGE("[-] Failed to open %s for writing.", out_image);
 		return 1;
 	}
 
 	/* Find the signature checking function via pattern matching */
 	if (fstat(aboot_fd, &st)) {
-		printf("[-] fstat() failed.\n");
+		LOGE("[-] fstat() failed.");
 		return 1;
 	}
 
 	aboot = mmap(0, (st.st_size + 0xfff) & ~0xfff, PROT_READ, MAP_PRIVATE, aboot_fd, 0);
 	if (aboot == MAP_FAILED) {
-		printf("[-] Failed to mmap aboot.\n");
+		LOGE("[-] Failed to mmap aboot.");
 		return 1;
 	}
 
@@ -519,7 +519,7 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	}
 
 	if (!target) {
-		printf("[-] Failed to find function to patch.\n");
+		LOGE("[-] Failed to find function to patch.");
 		return 1;
 	}
 
@@ -533,21 +533,21 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	}
 
 	if (!tgt) {
-		printf("[-] Unsupported aboot image.\n");
+		LOGE("[-] Unsupported aboot image.");
 		return 1;
 	}
 
-	printf("[+] Detected target %s %s build %s\n", tgt->vendor, tgt->device, tgt->build);
+	LOGV("[+] Detected target %s %s build %s", tgt->vendor, tgt->device, tgt->build);
 
 	/* Map the original boot/recovery image */
 	if (fstat(ifd, &st)) {
-		printf("[-] fstat() failed.\n");
+		LOGE("[-] fstat() failed.");
 		return 1;
 	}
 
 	orig = mmap(0, (st.st_size + 0x2000 + 0xfff) & ~0xfff, PROT_READ|PROT_WRITE, MAP_PRIVATE, ifd, 0);
 	if (orig == MAP_FAILED) {
-		printf("[-] Failed to mmap input file.\n");
+		LOGE("[-] Failed to mmap input file.");
 		return 1;
 	}
 
@@ -555,15 +555,15 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	loki_hdr = orig + 0x400;
 
 	if (!memcmp(loki_hdr->magic, "LOKI", 4)) {
-		printf("[-] Input file is already a Loki image.\n");
+		LOGV("[-] Input file is already a Loki image.");
 
 		/* Copy the entire file to the output transparently */
 		if (write(ofd, orig, st.st_size) != st.st_size) {
-			printf("[-] Failed to copy Loki image.\n");
+			LOGE("[-] Failed to copy Loki image.");
 			return 1;
 		}
 
-		printf("[+] Copied Loki image to %s.\n", out_image);
+		LOGV("[+] Copied Loki image to %s.", out_image);
 
 		return 0;
 	}
@@ -579,8 +579,8 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	orig_kernel_size = hdr->kernel_size;
 	orig_ramdisk_size = hdr->ramdisk_size;
 
-	printf("[+] Original kernel address: %.08x\n", hdr->kernel_addr);
-	printf("[+] Original ramdisk address: %.08x\n", hdr->ramdisk_addr);
+	LOGV("[+] Original kernel address: %.08x", hdr->kernel_addr);
+	LOGV("[+] Original ramdisk address: %.08x", hdr->ramdisk_addr);
 
 	/* Store the original values in unused fields of the header */
 	loki_hdr->orig_kernel_size = orig_kernel_size;
@@ -588,7 +588,7 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	loki_hdr->ramdisk_addr = hdr->kernel_addr + ((hdr->kernel_size + page_mask) & ~page_mask);
 
 	if (patch_shellcode(tgt->hdr, hdr->ramdisk_addr) < 0) {
-		printf("[-] Failed to patch shellcode.\n");
+		LOGE("[-] Failed to patch shellcode.");
 		return 1;
 	}
 
@@ -611,7 +611,7 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 
 	/* Write the image header */
 	if (write(ofd, orig, page_size) != page_size) {
-		printf("[-] Failed to write header to output file.\n");
+		LOGE("[-] Failed to write header to output file.");
 		return 1;
 	}
 
@@ -619,7 +619,7 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 
 	/* Write the kernel */
 	if (write(ofd, orig + page_size, page_kernel_size) != page_kernel_size) {
-		printf("[-] Failed to write kernel to output file.\n");
+		LOGE("[-] Failed to write kernel to output file.");
 		return 1;
 	}
 
@@ -627,14 +627,14 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 
 	/* Write the ramdisk */
 	if (write(ofd, orig + page_size + page_kernel_size, page_ramdisk_size) != page_ramdisk_size) {
-		printf("[-] Failed to write ramdisk to output file.\n");
+		LOGE("[-] Failed to write ramdisk to output file.");
 		return 1;
 	}
 
 	/* Write fake_size bytes of original code to the output */
 	buf = malloc(fake_size);
 	if (!buf) {
-		printf("[-] Out of memory.\n");
+		LOGE("[-] Out of memory.");
 		return 1;
 	}
 
@@ -642,7 +642,7 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	read(aboot_fd, buf, fake_size);
 
 	if (write(ofd, buf, fake_size) != fake_size) {
-		printf("[-] Failed to write original aboot code to output file.\n");
+		LOGE("[-] Failed to write original aboot code to output file.");
 		return 1;
 	}
 
@@ -652,10 +652,10 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	/* Write the device tree if needed */
 	if (hdr->dt_size) {
 
-		printf("[+] Writing device tree.\n");
+		LOGV("[+] Writing device tree.");
 
 		if (write(ofd, orig + page_size + page_kernel_size + page_ramdisk_size, hdr->dt_size) != hdr->dt_size) {
-			printf("[-] Failed to write device tree to output file.\n");
+			LOGE("[-] Failed to write device tree to output file.");
 			return 1;
 		}
 	}
@@ -664,7 +664,7 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 
 	/* Write the patch */
 	if (write(ofd, patch, sizeof(patch)) != sizeof(patch)) {
-		printf("[-] Failed to write patch to output file.\n");
+		LOGE("[-] Failed to write patch to output file.");
 		return 1;
 	}
 
@@ -672,7 +672,7 @@ int loki_patch(const char* partition_label, const char* aboot_image, const char*
 	close(ofd);
 	close(aboot_fd);
 
-	printf("[+] Output file written to %s\n", out_image);
+	LOGV("[+] Output file written to %s", out_image);
 
 	return 0;
 }
diff --git a/loki_unlok.c b/loki_unlok.c
index f2e685a..71615ec 100644
--- a/loki_unlok.c
+++ b/loki_unlok.c
@@ -47,25 +47,25 @@ int loki_unlok(const char* in_image, const char* out_image)
 
 	ifd = open(in_image, O_RDONLY);
 	if (ifd < 0) {
-		printf("[-] Failed to open %s for reading.\n", in_image);
+		LOGE("[-] Failed to open %s for reading.", in_image);
 		return 1;
 	}
 
 	ofd = open(out_image, O_WRONLY|O_CREAT|O_TRUNC, 0644);
 	if (ofd < 0) {
-		printf("[-] Failed to open %s for writing.\n", out_image);
+		LOGE("[-] Failed to open %s for writing.", out_image);
 		return 1;
 	}
 
 	/* Map the original boot/recovery image */
 	if (fstat(ifd, &st)) {
-		printf("[-] fstat() failed.\n");
+		LOGE("[-] fstat() failed.");
 		return 1;
 	}
 
 	orig = mmap(0, (st.st_size + 0x2000 + 0xfff) & ~0xfff, PROT_READ|PROT_WRITE, MAP_PRIVATE, ifd, 0);
 	if (orig == MAP_FAILED) {
-		printf("[-] Failed to mmap input file.\n");
+		LOGE("[-] Failed to mmap input file.");
 		return 1;
 	}
 
@@ -73,15 +73,15 @@ int loki_unlok(const char* in_image, const char* out_image)
 	loki_hdr = orig + 0x400;
 
 	if (memcmp(loki_hdr->magic, "LOKI", 4)) {
-		printf("[-] Input file is not a Loki image.\n");
+		LOGE("[-] Input file is not a Loki image.");
 
 		/* Copy the entire file to the output transparently */
 		if (write(ofd, orig, st.st_size) != st.st_size) {
-			printf("[-] Failed to copy Loki image.\n");
+			LOGE("[-] Failed to copy Loki image.");
 			return 1;
 		}
 
-		printf("[+] Copied Loki image to %s.\n", out_image);
+		LOGV("[+] Copied Loki image to %s.", out_image);
 
 		return 0;
 	}
@@ -97,7 +97,7 @@ int loki_unlok(const char* in_image, const char* out_image)
 
 	orig_ramdisk_addr = find_ramdisk_addr(orig, st.st_size);
 	if (orig_ramdisk_addr == 0) {
-		printf("[-] Failed to find original ramdisk address.\n");
+		LOGE("[-] Failed to find original ramdisk address.");
 		return 1;
 	}
 
@@ -111,7 +111,7 @@ int loki_unlok(const char* in_image, const char* out_image)
 
 	/* Write the image header */
 	if (write(ofd, orig, page_size) != page_size) {
-		printf("[-] Failed to write header to output file.\n");
+		LOGE("[-] Failed to write header to output file.");
 		return 1;
 	}
 
@@ -119,7 +119,7 @@ int loki_unlok(const char* in_image, const char* out_image)
 
 	/* Write the kernel */
 	if (write(ofd, orig + page_size, page_kernel_size) != page_kernel_size) {
-		printf("[-] Failed to write kernel to output file.\n");
+		LOGE("[-] Failed to write kernel to output file.");
 		return 1;
 	}
 
@@ -127,18 +127,18 @@ int loki_unlok(const char* in_image, const char* out_image)
 
 	/* Write the ramdisk */
 	if (write(ofd, orig + page_size + page_kernel_size, page_ramdisk_size) != page_ramdisk_size) {
-		printf("[-] Failed to write ramdisk to output file.\n");
+		LOGE("[-] Failed to write ramdisk to output file.");
 		return 1;
 	}
 
 	/* Write the device tree if needed */
 	if (hdr->dt_size) {
 
-		printf("[+] Writing device tree.\n");
+		LOGV("[+] Writing device tree.");
 
 		/* Skip an additional fake_size (page_size of 0x200) bytes */
 		if (write(ofd, orig + page_size + page_kernel_size + page_ramdisk_size + fake_size, hdr->dt_size) != hdr->dt_size) {
-			printf("[-] Failed to write device tree to output file.\n");
+			LOGE("[-] Failed to write device tree to output file.");
 			return 1;
 		}
 	}
@@ -146,7 +146,7 @@ int loki_unlok(const char* in_image, const char* out_image)
 	close(ifd);
 	close(ofd);
 
-	printf("[+] Output file written to %s\n", out_image);
+	LOGV("[+] Output file written to %s", out_image);
 
 	return 0;
 }
-- 
2.0.4

