// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MBSWITCHROM_MBTOOL_DAEMON_V3_H_
#define FLATBUFFERS_GENERATED_MBSWITCHROM_MBTOOL_DAEMON_V3_H_

#include "flatbuffers/flatbuffers.h"


namespace mbtool {
namespace daemon {
namespace v3 {

struct MbSwitchRomRequest;
struct MbSwitchRomResponse;

enum MbSwitchRomResult {
  MbSwitchRomResult_SUCCEEDED = 0,
  MbSwitchRomResult_FAILED = 1,
  MbSwitchRomResult_CHECKSUM_NOT_FOUND = 2,
  MbSwitchRomResult_CHECKSUM_INVALID = 3,
  MbSwitchRomResult_MIN = MbSwitchRomResult_SUCCEEDED,
  MbSwitchRomResult_MAX = MbSwitchRomResult_CHECKSUM_INVALID
};

inline const char **EnumNamesMbSwitchRomResult() {
  static const char *names[] = { "SUCCEEDED", "FAILED", "CHECKSUM_NOT_FOUND", "CHECKSUM_INVALID", nullptr };
  return names;
}

inline const char *EnumNameMbSwitchRomResult(MbSwitchRomResult e) { return EnumNamesMbSwitchRomResult()[static_cast<int>(e)]; }

struct MbSwitchRomRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROM_ID = 4,
    VT_BOOT_BLOCKDEV = 6,
    VT_BLOCKDEV_BASE_DIRS = 8,
    VT_FORCE_UPDATE_CHECKSUMS = 10
  };
  const flatbuffers::String *rom_id() const { return GetPointer<const flatbuffers::String *>(VT_ROM_ID); }
  const flatbuffers::String *boot_blockdev() const { return GetPointer<const flatbuffers::String *>(VT_BOOT_BLOCKDEV); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *blockdev_base_dirs() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_BLOCKDEV_BASE_DIRS); }
  bool force_update_checksums() const { return GetField<uint8_t>(VT_FORCE_UPDATE_CHECKSUMS, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROM_ID) &&
           verifier.Verify(rom_id()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BOOT_BLOCKDEV) &&
           verifier.Verify(boot_blockdev()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BLOCKDEV_BASE_DIRS) &&
           verifier.Verify(blockdev_base_dirs()) &&
           verifier.VerifyVectorOfStrings(blockdev_base_dirs()) &&
           VerifyField<uint8_t>(verifier, VT_FORCE_UPDATE_CHECKSUMS) &&
           verifier.EndTable();
  }
};

struct MbSwitchRomRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rom_id(flatbuffers::Offset<flatbuffers::String> rom_id) { fbb_.AddOffset(MbSwitchRomRequest::VT_ROM_ID, rom_id); }
  void add_boot_blockdev(flatbuffers::Offset<flatbuffers::String> boot_blockdev) { fbb_.AddOffset(MbSwitchRomRequest::VT_BOOT_BLOCKDEV, boot_blockdev); }
  void add_blockdev_base_dirs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> blockdev_base_dirs) { fbb_.AddOffset(MbSwitchRomRequest::VT_BLOCKDEV_BASE_DIRS, blockdev_base_dirs); }
  void add_force_update_checksums(bool force_update_checksums) { fbb_.AddElement<uint8_t>(MbSwitchRomRequest::VT_FORCE_UPDATE_CHECKSUMS, static_cast<uint8_t>(force_update_checksums), 0); }
  MbSwitchRomRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MbSwitchRomRequestBuilder &operator=(const MbSwitchRomRequestBuilder &);
  flatbuffers::Offset<MbSwitchRomRequest> Finish() {
    auto o = flatbuffers::Offset<MbSwitchRomRequest>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<MbSwitchRomRequest> CreateMbSwitchRomRequest(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> rom_id = 0,
   flatbuffers::Offset<flatbuffers::String> boot_blockdev = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> blockdev_base_dirs = 0,
   bool force_update_checksums = false) {
  MbSwitchRomRequestBuilder builder_(_fbb);
  builder_.add_blockdev_base_dirs(blockdev_base_dirs);
  builder_.add_boot_blockdev(boot_blockdev);
  builder_.add_rom_id(rom_id);
  builder_.add_force_update_checksums(force_update_checksums);
  return builder_.Finish();
}

struct MbSwitchRomResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESS = 4,
    VT_RESULT = 6
  };
  bool success() const { return GetField<uint8_t>(VT_SUCCESS, 0) != 0; }
  MbSwitchRomResult result() const { return static_cast<MbSwitchRomResult>(GetField<int16_t>(VT_RESULT, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<int16_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct MbSwitchRomResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) { fbb_.AddElement<uint8_t>(MbSwitchRomResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0); }
  void add_result(MbSwitchRomResult result) { fbb_.AddElement<int16_t>(MbSwitchRomResponse::VT_RESULT, static_cast<int16_t>(result), 0); }
  MbSwitchRomResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MbSwitchRomResponseBuilder &operator=(const MbSwitchRomResponseBuilder &);
  flatbuffers::Offset<MbSwitchRomResponse> Finish() {
    auto o = flatbuffers::Offset<MbSwitchRomResponse>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<MbSwitchRomResponse> CreateMbSwitchRomResponse(flatbuffers::FlatBufferBuilder &_fbb,
   bool success = false,
   MbSwitchRomResult result = MbSwitchRomResult_SUCCEEDED) {
  MbSwitchRomResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_success(success);
  return builder_.Finish();
}

}  // namespace v3
}  // namespace daemon
}  // namespace mbtool

#endif  // FLATBUFFERS_GENERATED_MBSWITCHROM_MBTOOL_DAEMON_V3_H_
